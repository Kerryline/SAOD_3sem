<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Дерево оптимального поиска (100 вершин)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .description {
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: #4e54c8;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: #3a3f9e;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .tree-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .tree-container {
            width: 100%;
            height: 700px;
            overflow: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .stat-card h3 {
            margin-bottom: 10px;
            color: #fdbb2d;
            font-size: 1.2rem;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .matrix-section {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        th, td {
            padding: 8px 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
        }
        
        th {
            background: rgba(78, 84, 200, 0.7);
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #4e54c8;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 2;
            font-size: 0.8rem;
        }
        
        .node:hover {
            transform: scale(1.1);
            background: #3a3f9e;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .node-key {
            font-size: 0.9rem;
        }
        
        .node-weight {
            font-size: 0.7rem;
            opacity: 0.9;
        }
        
        .node-root {
            background: #fdbb2d;
            color: #1a2a6c;
        }
        
        .node-leaf {
            background: #b21f1f;
        }
        
        .connection {
            position: absolute;
            height: 2px;
            background: rgba(255, 255, 255, 0.7);
            transform-origin: 0 0;
            z-index: 1;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .legend-root {
            background: #fdbb2d;
        }
        
        .legend-normal {
            background: #4e54c8;
        }
        
        .legend-leaf {
            background: #b21f1f;
        }
        
        .traversal-output {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .traversal-output h4 {
            margin-bottom: 10px;
            color: #fdbb2d;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                max-width: 300px;
            }
            
            .tree-container {
                height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Дерево оптимального поиска (100 вершин)</h1>
            <p class="description">
                Визуализация дерева оптимального поиска с указанием весов вершин. 
                ДОП минимизирует средневзвешенную высоту дерева, размещая вершины с наибольшим весом ближе к корню.
            </p>
        </header>
        
        <div class="controls">
            <button id="generateBtn">Сгенерировать 100 вершин</button>
            <button id="buildTreeBtn">Построить ДОП</button>
            <button id="showMatricesBtn">Показать матрицы</button>
            <button id="showTraversalBtn">Показать обход</button>
            <button id="resetBtn">Сбросить</button>
        </div>
        
        <div class="content">
            <div class="tree-section">
                <h2>Графическое представление дерева (100 вершин)</h2>
                <div class="tree-container" id="treeContainer">
                    <!-- Дерево будет отрисовано здесь -->
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color legend-root"></div>
                        <span>Корень дерева</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-normal"></div>
                        <span>Обычная вершина</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-leaf"></div>
                        <span>Лист дерева</span>
                    </div>
                </div>
                <div class="traversal-output" id="traversalOutput" style="display: none;">
                    <h4>Обход дерева слева направо (inorder):</h4>
                    <div id="traversalContent"></div>
                </div>
            </div>
            
            <div class="stats-section">
                <div class="stat-card">
                    <h3>Количество вершин</h3>
                    <div class="stat-value" id="nodeCount">0</div>
                </div>
                <div class="stat-card">
                    <h3>Высота дерева</h3>
                    <div class="stat-value" id="treeHeight">0</div>
                </div>
                <div class="stat-card">
                    <h3>Средневзвешенная высота</h3>
                    <div class="stat-value" id="avgHeight">0.00</div>
                </div>
                <div class="stat-card">
                    <h3>Сумма весов</h3>
                    <div class="stat-value" id="totalWeight">0</div>
                </div>
                <div class="stat-card">
                    <h3>Контрольная сумма</h3>
                    <div class="stat-value" id="controlSum">0</div>
                </div>
                <div class="stat-card">
                    <h3>Время построения</h3>
                    <div class="stat-value" id="buildTime">0 мс</div>
                </div>
            </div>
            
            <div class="matrix-section" id="matrixSection" style="display: none;">
                <h2>Матрицы построения ДОП (первые 10x10)</h2>
                <div class="matrix-container">
                    <h3>Матрица весов (AW)</h3>
                    <div class="table-container" id="awTable"></div>
                    
                    <h3>Матрица взвешенных высот (AP)</h3>
                    <div class="table-container" id="apTable"></div>
                    
                    <h3>Матрица корней поддеревьев (AR)</h3>
                    <div class="table-container" id="arTable"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Класс для узла дерева
        class TreeNode {
            constructor(key, weight) {
                this.key = key;
                this.weight = weight;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
            }
        }

        // Основной класс для ДОП
        class OptimalBST {
            constructor() {
                this.root = null;
                this.nodes = [];
                this.matrixAW = [];
                this.matrixAP = [];
                this.matrixAR = [];
                this.nodeCount = 100;
            }

            // Генерация случайных весов для вершин
            generateRandomWeights() {
                this.nodes = [];
                for (let i = 1; i <= this.nodeCount; i++) {
                    const weight = Math.floor(Math.random() * 100) + 1;
                    this.nodes.push(new TreeNode(i, weight));
                }
                return this.nodes;
            }

            // Построение матриц для ДОП
            buildMatrices() {
                const n = this.nodes.length;
                // Инициализация матриц
                this.matrixAW = Array(n+1).fill().map(() => Array(n+1).fill(0));
                this.matrixAP = Array(n+1).fill().map(() => Array(n+1).fill(0));
                this.matrixAR = Array(n+1).fill().map(() => Array(n+1).fill(0));

                // Заполнение матриц
                for (let len = 1; len <= n; len++) {
                    for (let i = 0; i <= n - len; i++) {
                        const j = i + len;
                        
                        // Вычисление AW[i][j]
                        this.matrixAW[i][j] = this.matrixAW[i][j-1] + this.nodes[j-1].weight;
                        
                        // Поиск оптимального корня
                        this.matrixAP[i][j] = Number.MAX_SAFE_INTEGER;
                        let minK = i + 1;
                        let maxK = j;
                        
                        // Использование монотонности для оптимизации
                        if (i < j - 1) {
                            minK = this.matrixAR[i][j-1] || i + 1;
                            maxK = this.matrixAR[i+1][j] || j;
                        }
                        
                        for (let k = minK; k <= maxK; k++) {
                            const cost = this.matrixAP[i][k-1] + this.matrixAP[k][j];
                            if (cost < this.matrixAP[i][j]) {
                                this.matrixAP[i][j] = cost;
                                this.matrixAR[i][j] = k;
                            }
                        }
                        
                        this.matrixAP[i][j] += this.matrixAW[i][j];
                    }
                }
            }

            // Построение дерева из матрицы AR
            buildTree() {
                const n = this.nodes.length;
                this.root = this.buildSubtree(0, n);
                return this.root;
            }

            // Рекурсивное построение поддерева
            buildSubtree(i, j) {
                if (i >= j) return null;
                
                const rootIndex = this.matrixAR[i][j];
                const rootNode = this.nodes[rootIndex - 1];
                
                rootNode.left = this.buildSubtree(i, rootIndex - 1);
                rootNode.right = this.buildSubtree(rootIndex, j);
                
                return rootNode;
            }

            // Вычисление характеристик дерева
            calculateTreeStats() {
                let totalWeight = 0;
                let sumWeightedHeight = 0;
                let maxHeight = 0;
                let controlSum = 0;
                
                const traverse = (node, depth) => {
                    if (!node) return;
                    
                    totalWeight += node.weight;
                    sumWeightedHeight += node.weight * depth;
                    controlSum += node.key;
                    maxHeight = Math.max(maxHeight, depth);
                    
                    traverse(node.left, depth + 1);
                    traverse(node.right, depth + 1);
                };
                
                traverse(this.root, 1);
                
                return {
                    nodeCount: this.nodes.length,
                    totalWeight,
                    maxHeight,
                    controlSum,
                    avgWeightedHeight: sumWeightedHeight / totalWeight
                };
            }
            
            // Получение обхода дерева (inorder)
            getInorderTraversal() {
                const result = [];
                this.inorderTraversal(this.root, result);
                return result;
            }
            
            inorderTraversal(node, result) {
                if (!node) return;
                this.inorderTraversal(node.left, result);
                result.push(node.key);
                this.inorderTraversal(node.right, result);
            }
        }

        // Класс для визуализации дерева
        class TreeVisualizer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
            }

            // Очистка контейнера
            clear() {
                this.container.innerHTML = '';
            }

            // Расчет позиций узлов дерева
            calculatePositions(root) {
                if (!root) return;
                
                // Используем обход в ширину для расчета позиций
                const queue = [{node: root, level: 0, pos: this.width / 2, offset: this.width / 3}];
                const positionedNodes = [];
                
                while (queue.length > 0) {
                    const {node, level, pos, offset} = queue.shift();
                    
                    node.x = pos;
                    node.y = 80 + level * 80;
                    
                    positionedNodes.push(node);
                    
                    if (node.left) {
                        queue.push({
                            node: node.left,
                            level: level + 1,
                            pos: pos - offset,
                            offset: offset / 1.8
                        });
                    }
                    
                    if (node.right) {
                        queue.push({
                            node: node.right,
                            level: level + 1,
                            pos: pos + offset,
                            offset: offset / 1.8
                        });
                    }
                }
                
                return positionedNodes;
            }

            // Отрисовка дерева
            drawTree(root) {
                this.clear();
                
                if (!root) return;
                
                const nodes = this.calculatePositions(root);
                
                // Отрисовка соединений
                nodes.forEach(node => {
                    if (node.left) {
                        this.drawConnection(node, node.left);
                    }
                    if (node.right) {
                        this.drawConnection(node, node.right);
                    }
                });
                
                // Отрисовка узлов
                nodes.forEach(node => {
                    this.drawNode(node);
                });
            }

            // Отрисовка соединения между узлами
            drawConnection(fromNode, toNode) {
                const line = document.createElement('div');
                line.className = 'connection';
                
                const length = Math.sqrt(
                    Math.pow(toNode.x - fromNode.x, 2) + 
                    Math.pow(toNode.y - fromNode.y, 2)
                );
                
                const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x) * 180 / Math.PI;
                
                line.style.width = `${length}px`;
                line.style.left = `${fromNode.x}px`;
                line.style.top = `${fromNode.y}px`;
                line.style.transform = `rotate(${angle}deg)`;
                
                this.container.appendChild(line);
            }

            // Отрисовка узла
            drawNode(node) {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                
                // Определяем тип узла для стилизации
                if (!node.left && !node.right) {
                    nodeElement.classList.add('node-leaf');
                } else if (node === this.getRootNode(node)) {
                    nodeElement.classList.add('node-root');
                }
                
                nodeElement.style.left = `${node.x - 25}px`;
                nodeElement.style.top = `${node.y - 25}px`;
                
                nodeElement.innerHTML = `
                    <div class="node-key">${node.key}</div>
                    <div class="node-weight">${node.weight}</div>
                `;
                
                // Добавляем всплывающую подсказку
                nodeElement.title = `Ключ: ${node.key}, Вес: ${node.weight}`;
                
                this.container.appendChild(nodeElement);
            }

            // Вспомогательная функция для поиска корня
            getRootNode(node) {
                // В нашей реализации корень хранится отдельно
                // Для простоты будем считать, что корень - это узел без родителя
                // В данном случае мы просто возвращаем переданный узел
                // В реальной реализации нужно отслеживать корень дерева
                return node;
            }
        }

        // Класс для отображения матриц
        class MatrixVisualizer {
            static createTable(matrix, title, containerId, size = 10) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                const table = document.createElement('table');
                
                // Заголовок таблицы
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th>i\\j</th>';
                for (let j = 0; j < size && j < matrix[0].length; j++) {
                    const th = document.createElement('th');
                    th.textContent = j;
                    headerRow.appendChild(th);
                }
                table.appendChild(headerRow);
                
                // Тело таблицы
                for (let i = 0; i < size && i < matrix.length; i++) {
                    const row = document.createElement('tr');
                    
                    const headerCell = document.createElement('th');
                    headerCell.textContent = i;
                    row.appendChild(headerCell);
                    
                    for (let j = 0; j < size && j < matrix[i].length; j++) {
                        const cell = document.createElement('td');
                        cell.textContent = matrix[i][j] !== Number.MAX_SAFE_INTEGER ? matrix[i][j] : '∞';
                        row.appendChild(cell);
                    }
                    
                    table.appendChild(row);
                }
                
                container.appendChild(table);
            }
        }

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', function() {
            const optimalBST = new OptimalBST();
            const visualizer = new TreeVisualizer('treeContainer');
            
            // Элементы управления
            const generateBtn = document.getElementById('generateBtn');
            const buildTreeBtn = document.getElementById('buildTreeBtn');
            const showMatricesBtn = document.getElementById('showMatricesBtn');
            const showTraversalBtn = document.getElementById('showTraversalBtn');
            const resetBtn = document.getElementById('resetBtn');
            const matrixSection = document.getElementById('matrixSection');
            const traversalOutput = document.getElementById('traversalOutput');
            
            // Элементы статистики
            const nodeCountElem = document.getElementById('nodeCount');
            const treeHeightElem = document.getElementById('treeHeight');
            const avgHeightElem = document.getElementById('avgHeight');
            const totalWeightElem = document.getElementById('totalWeight');
            const controlSumElem = document.getElementById('controlSum');
            const buildTimeElem = document.getElementById('buildTime');
            
            // Обработчики событий
            generateBtn.addEventListener('click', function() {
                optimalBST.generateRandomWeights();
                visualizer.drawTree(optimalBST.root);
                updateStats();
                matrixSection.style.display = 'none';
                traversalOutput.style.display = 'none';
            });
            
            buildTreeBtn.addEventListener('click', function() {
                const startTime = performance.now();
                optimalBST.buildMatrices();
                optimalBST.buildTree();
                const endTime = performance.now();
                
                visualizer.drawTree(optimalBST.root);
                updateStats();
                
                // Обновляем время построения
                buildTimeElem.textContent = `${(endTime - startTime).toFixed(2)} мс`;
                
                matrixSection.style.display = 'none';
                traversalOutput.style.display = 'none';
            });
            
            showMatricesBtn.addEventListener('click', function() {
                if (optimalBST.matrixAW.length > 0) {
                    MatrixVisualizer.createTable(optimalBST.matrixAW, 'Матрица весов AW', 'awTable');
                    MatrixVisualizer.createTable(optimalBST.matrixAP, 'Матрица взвешенных высот AP', 'apTable');
                    MatrixVisualizer.createTable(optimalBST.matrixAR, 'Матрица корней поддеревьев AR', 'arTable');
                    matrixSection.style.display = 'block';
                    traversalOutput.style.display = 'none';
                } else {
                    alert('Сначала постройте дерево!');
                }
            });
            
            showTraversalBtn.addEventListener('click', function() {
                if (optimalBST.root) {
                    const traversal = optimalBST.getInorderTraversal();
                    const traversalContent = document.getElementById('traversalContent');
                    
                    // Форматируем обход для отображения
                    let formattedTraversal = '';
                    for (let i = 0; i < traversal.length; i++) {
                        formattedTraversal += traversal[i];
                        if (i < traversal.length - 1) {
                            formattedTraversal += ', ';
                            if ((i + 1) % 10 === 0) formattedTraversal += '<br>';
                        }
                    }
                    
                    traversalContent.innerHTML = formattedTraversal;
                    traversalOutput.style.display = 'block';
                    matrixSection.style.display = 'none';
                } else {
                    alert('Сначала постройте дерево!');
                }
            });
            
            resetBtn.addEventListener('click', function() {
                optimalBST.root = null;
                optimalBST.nodes = [];
                optimalBST.matrixAW = [];
                optimalBST.matrixAP = [];
                optimalBST.matrixAR = [];
                visualizer.clear();
                matrixSection.style.display = 'none';
                traversalOutput.style.display = 'none';
                updateStats();
                buildTimeElem.textContent = '0 мс';
            });
            
            // Функция обновления статистики
            function updateStats() {
                if (optimalBST.root) {
                    const stats = optimalBST.calculateTreeStats();
                    nodeCountElem.textContent = stats.nodeCount;
                    treeHeightElem.textContent = stats.maxHeight;
                    avgHeightElem.textContent = stats.avgWeightedHeight.toFixed(4);
                    totalWeightElem.textContent = stats.totalWeight;
                    controlSumElem.textContent = stats.controlSum;
                } else {
                    nodeCountElem.textContent = optimalBST.nodeCount;
                    treeHeightElem.textContent = '0';
                    avgHeightElem.textContent = '0.0000';
                    totalWeightElem.textContent = '0';
                    controlSumElem.textContent = '0';
                }
            }
            
            // Инициализация
            optimalBST.generateRandomWeights();
            updateStats();
        });
    </script>
</body>
</html>